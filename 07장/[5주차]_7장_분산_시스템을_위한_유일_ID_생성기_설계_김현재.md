# 개요
분산 시스템에서 우리가 DB의 ID를 만들 시에 auto_incremt 를 사용하면 되지 않을까 하는 막연한 생각을 할  수 도 있을 것이다. 하지만 이 경우 여러 DB 서버를 사용하는 경우 ID의 유일성을 보장하기 위해서 Lock을 걸어줘야 할 것이고 이는 결국 병목을 발생시키게 될 것이기 때문이다.
<br>
<br>

# 문제 이해 및 설계 범위 확정, 개략적 설계 안 제시 및 동의 구하기
### 문제 이해 및 설계 범위 확정 
다음과 같은 경우에 대해서 미리 고려해 볼 필요가 있을 것 같다.
- ID는 유일하고, 정렬 가능해야한다.
- 새로운 record에 붙일 ID는 시간에 따라 값은 커져야 한다.
- ID는 숫자로만 구성되어야한다.
- ID는 64bit로 표현될 수 있는 값이어야 한다.
- 초당 10,000 개의 ID를 만들 수 있어야한다.

### 개략적 설계안 제시 및 동의 구하기

분산 시스템에서 유일성이 보장되는 ID를 만드는 방법의 선택지는 
- 다중 마스터 복제
- UUID
- 티켓 서버
- 트위터 스노 플레이크 접근법
이 있다.
<br>
<br>


# 구현 방법
---
### 다중 마스터 복제
데이터 베이스의 auto_increment 를 활용하는 것이다. 다만 다음 ID의 값을 구할때 1만큼 증가시켜 얻는 것이 아닌 k만큼 증가시킨다.
k는 현재 사용중인 데이터베이스 수가 된다. 
규모 확장성 문제가 어느정도 해결된다. 데이터베이스 수를 늘리면 초당 생산 가능 ID 수도 늘릴 수 있기 때문이다.

하지만 다음과 같은 단점이 있다.
- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다. -> 이유를 찾아보기
- ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
- 서버를 추가하거나 삭제할때도 잘 동작하도록 만들기 어렵다.

---
### UUID
UUID는 유일성이 보장되는 ID를 만드는 간단한 방법이다. UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128bit 짜리 수다. UUID 값은 충돌 가능성이 지극히 낮다.
중복 UUID가 1개 생길 확률을 50%까지 높이기 위해서는 초당 10억개의 UUID를 100년 동안 계속해서 만들어야한다.

UUID는 서버 간 조율 없이 독립적으로 생성 가능하다. UUID를 사용하는 시스템의 구조다.

각 웹 서버는 별도의 별도의 ID 생성기를 사용해 독립적으로 ID를 만들어 낸다.

**장점**
- UUID를 만드는 것은 단순하다. 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장이 쉽다.

**단점**
- ID가 128비트로 길다. 
- ID를 시간 순서로 정렬 불가능하다.
- ID에 숫자 아닌 값이 포함될 수 있다.
---
### 티켓 서버
티켓 서버는 유일성이 보장되는 ID를 만들어 내는데 쓰일 수 있다. 이 아이디어의 핵심은 auto_increment를 갖춘 데이터 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것이다. 

**장점**
- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.

**단점**
- 티켓 서버가 SPOF가 된다. 티켓 서버가 장애가 발생하면 해당 서버를 이용하는 시스템이 영향을 받는다. 이 이슈를 피하려면 티켓 서버를 여러 대 준비해야하는데, 그렇게 하면 데이터 동기화 같은 새로운 문제가 발생한다.
---
### 트위터 스노플레이크 접근법
트위터는 스노 플레이크라고 부르는 독창적인 ID 생성 기법을 사용한다. ID를 바로 생성하기 보다는 각개 격파 전략을 먼저 적용해보자. 생성해야하는 ID 구조를 여러 절로 분할 하는 것이다.

- 사인 비트: 1비트를 할당한다. 음수와 양수를 구분하기 위해 사용될 수도 있다.
- 타임 스탬프: 41bit를 할당한다. 기원 시각(epoch) 이후로 몇 밀리초가 경과했는지를 나타내는 값이다. 
- 데이터 센터 ID: 5비트를 할당한다. 따라서 2^5=32개 데이터 센터를 지원할 수 있다.
- 서버 ID: 5비트를 할당한다. 따라서 데이터 센터 당 32개 서버를 사용할 수 있다.
- 일련 번호: 12비트를 할당한다. 각 서버에서는 ID를 생성할 때마다 일련번호를 1만큼 증가시킨다. 이 값은 1밀리초가 경과할때마다 0으로 초기화한다.

<br>
<br>

# 상세 설계
데이터 센터 ID와 서버 ID는 시스템이 시작할 때 결정되며 , 일반적으로 시스템 운영 중에는 바뀌지 않는다. 데이터 센터 ID나 서버 ID를 잘못 변경하게 되면 ID 충돌이 발생할 수 있으므로, 그런 작업을 할때는 신중해야한다. 타임 스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어지는 값이다. 


### 타임 스탬프
타임 스탬프는 ID구조에서 가장 중요한 41비트를 차지하고 있다. 타임 스탬프는 시간의 흐름에 따라 점점 큰 값을 갖게 되므로, 결국 ID는 시간 순으로 정렬 가능하게 되는 것이다. 
에포크 타임은 UTC 시각으로 변환해서 실제 시간을 알아낼 수 있다.
타임 스탬프의 최댓값은 2^41-1= 2199023255551밀리초이다. 이 값은 대략 69년에 해당한다. 기원 시각을 현재에 가깝게 맞춰서 오버플로가 발생하는 시점을 느춰놓은 후, 69년이 지나면 기원시간을 바꾸거나 ID체계를 migration할 필요가 있다.

### 일련 번호
일련 번호는 12비트이므로, 2^12=4096개의 값을 가질 수 있다. 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.
<br>

# 마무리
스노플레이크 방식을 사용하면 모든 요구사항을 만족하면서도 분산 환경에서 규모 확장이 가능하다.

설계 진행 후 더 논의할 만한 사항으로는 

- 시계동기화: ID 생성 서버들이 전부 같은 시계를 사용한다 가정하면 문제가 없지만, 하지만 하나의 서버가 여러 코어에서 실행될 경우 가정이 틀어질 수도 있다. 여러 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우에도 마찬가지다. NTP는 이러한 문제를 해결하는 가장 보편적인 수단이다. 
- 각 절의 길이 최적화: 동시성이 낮고 수명이 긴 애플리케이션일 시 일련번호 길이를 줄이고 타임 스탬프 절의 길이를 늘리는 것이 효과적일 것이다.
- 고가용성: ID 생성기는 필수 불가결 컴포넌트이므로 아주 높은 가용성을 제공해야 할 것이다.
