> **7장. 분산 시스템을 위한 유일 ID 생성기 설계**

<details>
  <summary><b>문제 이해 및 설계 범위 확정</b></summary>
  
    
  ---
  
  ## 문제 이해 및 설계 범위 확정
  
  ### 유일 ID 생성기
  
  - **`AUTO_INCREMENT` 속성이 설정된 관계형 데이터베이스의 기본 키**
      - 분산환경에서 데이터베이스 한 대로는 요구를 감당할 수 없음
      - 여러 데이터베이스 서버를 쓰는 경우에는 지연시간(delay)을 낮추기 힘듬
      
    <img src="https://github.com/user-attachments/assets/164955a1-9971-4e37-a8c7-3b4052f96cae" width="400px" />
      
  
  ### 1단계: 문제 이해 및 설계 범위 확정
  
  - **Q**. ID는 어떤 특성을 갖나요?
  - **A**. ID는 유일해야 하고, 정렬 가능
  - **Q**. 새로운 레코드에 붙일 ID는 항상 1만큼 큰 값이어야 하나요?
  - **A**. ID의 값은 시간의 흐름에 따라 커지지만 항상 1씩 증가한다고 할 수 는 없음
  - **Q**.. ID는 숫자로만 구성되나요?
  - **A**. 네
  - **Q**. 시스템의 규모는?
  - **A**. 초당 10,000 ID를 생성할 수 있어야 함
  
  ### **문제에 대한 요구사항**
  
  - ID는 유일
  - ID는 숫자로만 구성
  - ID는 64비트로 표현될 수 있는 값
  - ID는 발급 날짜에 따라 정렬 가능
  - 초당 10,000의 ID 생성 가능
  
  ---

  
</details>
<details>
  <summary><b>개략적 설계안 제시 및 동의 구하기</b></summary>
    
  ---
  
  ## 개략적 설계안 제시 및 동의 구하기
  
  ### 분산 시스템에서 유일성이 보장되는 ID를 만드는 방법
  
  - 다중 마스터 복제(Multi-master Replication)
  - UUID(Universally Unique Identifier)
  - 티켓 서버(Ticket Server)
  - 트위터 스노플레이크(Twitter Snowflake) 접근법
  
  ### 1️⃣ 다중 마스터 복제(Multi-master Replicatoin)
  
  - **구성**
      
    <img src="https://github.com/user-attachments/assets/903bb386-0aaf-4984-956b-6ca726dca7dd" width="100px"/>

      
  - **데이터베이스의 `auto_increment` 기능 활용**
      - ID의 값을 구할 때 `k`만큼 증가, `k`는 사용 중인 **데이터베이스 서버 수**
      - 규모 확장성 문제 어느 정도 해결 : DB 수를 늘리면, 초당 생산 가능 ID 수도 늘릴 수 있음
  - **단점**
      - 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
      - ID의 유일성은 보장되겠지만, 그 값이 **시간 흐름에 맞추어 커지도록 보장할 수 없음**
      - **서버를 추가하거나 삭제**할 때도 잘 동작하도록 만들기 어려움
  
  ### 2️⃣ UUID
  
  - **컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128bit 수**
      - 유일성이 보장되는 ID를 만드는 간단한 방법
      - UUID 값은 충돌 가능성이 지극히 낮음
      
      > **위키피디아)**
      > 
      > 
      > 중복 UUID가 1개 생길 확률을 50%로 끌어 올리려면 초당 10억 개의 UUID를 100년동안 계속해서 만들어야 함.
      > 
  - UUID 형태 :  `09c93e62-50b4-468d-bf8a-c07e1040bfb2`
  - UUID는 서버 간 조율 없이 독립적으로 생성 가능
  - **UUID를 사용하는 시스템 구조**
      
    <img src="https://github.com/user-attachments/assets/bdae8831-47a7-4e51-a928-aff9223b9669" witdth="400px"/>

      
      - **각 웹 서버는 별도의 ID 생성기를 사용**해 독립적으로 ID를 만들어 냄
  - **장점**
      - UUID를 만드는 것이 단순
      - 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없음
      - 각 서버가 자기가 쓸 ID를 알아서 만드는 구조, 규모 확장 쉬움
  - **단점**
      - ID가 128bit로 김
      - ID를 시간순으로 정렬할 수 없음
      - ID에 숫자(Numeric)가 아닌 값이 포함될 수 있음
  
  ### 3️⃣ 티켓 서버(Ticket Server)
  
  - **`auto_increment` 기능을 갖춘 데이터베이스(티켓 서버)를 중앙 집중형으로 하나만 사용**
      - 유일성이 보장되는 ID를 만들어 내는 방법
      - 플리커(Flickr)가 분산 기본 키(Distributed Primary Key)를 만들어 내기 위해 사용
  - **티켓 서버 구조**
      
    <img src="https://github.com/user-attachments/assets/3e0b59cd-53f8-474f-b3a9-27c761447d67" width="400px"/>
      
  - **장점**
      - 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있음
      - 구현하기 쉽고, 중소 규모 애플리케이션에 적합
  - **단점**
      - 티켓 서버가 SPOF(Sinle-Point-of-Failure)가 된다
      - SPOF를 피하기 위해 티켓 서버를 여러 대 준비하면 데이터 동기화 문제 발생
  
  ### 4️⃣ 트위터 스노플레이크(Snowflake) 접근법
  
  - 트위터는 스노플레이크라는 독창적인 ID 생성 기법 사용 : **타임스탬프를 ID에 사용**
  - **각개 격파 전략(Divide and Conquer)**
      - 생성해야 하는 **ID의 구조를 여러 절(Section)로 분할**
      - **64bit ID 구조**
          
        <img src="https://github.com/user-attachments/assets/7189daa9-c2a5-4142-9cfd-5b6393780d10" width="400px"/>

          
      - **사인(Sign) 비트**
          - 1bit 힐당
          - 현재는 쓰임새가 없지만 나중을 위해 유보
          - 음수와 양수를 구분하는데 사용할 수 있음
      - **타임스탬프(Timestamp)**
          - 41bit 할당
          - 기원 시간(epoch) 이후로 몇 밀리초(millisecond)가 경과헀는지를 나타내는 값
          - ex) `1288834974657(Now 04, 2010, 01:42:54 UTC에 해당)`
      - **데이터 센터 ID**
          - 5bit 할당
          - $2^5 = 32$개 데이터 센터 지원 가능
          - 시스템 시작 시 결정, 시스템 운영 중에 바뀌지 않음
      - **서버 ID**
          - 5bit 할당
          - $2^5=32$, 데이터 센터 당 32개 서버 사용 가능
          - 시스템 시작 시 결정, 시스템 운영 중에 바뀌지 않음
      - **일련번호**
          - 12bit 할당
          - 각 서버에서는 ID를 생성할 때마다 이 일련번호를 1만큼 증가
          - **1밀리초가 경과할 때마다 0으로 초기화**
  
  ---
    
</details>
<details>
  <summary><b>상세 설계</b></summary>
    
  ---
  
  ## 상세 설계
  
  ### **상세 설계: 스노플레이크 접근법**
  
  - **타임스탬프**
      - 타임스팸프는 시간의 흐름에 따라 점점 큰 값을 가짐, **ID는 시간순으로 정렬됨**
      - **예제) ID 구조를 따른 이진 표현 형태로부터 UTC 시각 추출**
          
        <img src="https://github.com/user-attachments/assets/5f9b6f1f-9f09-480b-912d-e18662d02ed5" width="400px"/>

          
          - 역으로 적용하면 UTC 시각을 타임스탬프로 변환 가능
      - **41bit로 표현** 타임스탬프의 최댓값 : $2^41-1=2199023255551$밀리초 **약 69년**
      - **ID 생성기는 69년 동안만 정상 동작**
      - 69년이 지나면 **기원 시각을 바꾸거나 ID 체계를 다른 것으로 이전(Migration)**
  - **일련번호**
      - 12bit, $2^{12}=4096$개 값을 가질 수 있음
      - 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 가짐
  
  ---

</details>
<details>
  <summary><b>마무리</b></summary>
  
  ---
  
  ## 마무리
  
  ### **ID 생성기 구현 전략**
  
  - 다중 마스터 복제
  - UUID
  - 티켓 서버
  - **트위터 스노플레이크**
      - 모든 요구사항을 만족하면서도, 분산 환경에 규모 확장 가능
      
  
  ### **추가 논의 사항**
  
  - **시계 동기화(Clock Synchronization)**
      - **각 서버가 다른 시계를 사용**
          - 하나의 서버가 여러 코어에서 실행되는 경우
          - 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우
      - **NTP(Network Time Protocol)** 를 통해 해결
  - **각 절(Section)의 길이 최적화**
      - **동시성(Concurrency)** 이 낮고 수명이 긴 애플리케이션
      - 일련번호 절의 길이를 줄이고 타임 스탬의 절의 길이를 늘리는 것이 경우에 따라 효과적
  - **고가용성(High Availability)**
      - ID 생성기는 **필수 불가결(Mission Critical) 컴포넌트**, 아주 높은 가용성 제공 필요
  
  ---

</details>
    
