# 7. 분산 시스템을 위한 유일 ID 생성기 설계

분산 환경에서는 우리가 일반적으로 사용하는 auto_increment 속성으로 관계형데이터베이스 기본키를 사용하기 어렵다. 
데이터베이스 서버 한 대로는 그 요구를 감당할 수 없을 뿐더러, 여러 데이터베이스 서버를 쓰는 경우에는 지연을 낮추기가 무척 힘들기 때문이다.

### 설계 범위
- ID는 유일
- ID는 숫자로만 구성
- ID는 64비트로 표현될 수 있는 값
- ID는 발급 날짜에 따라 정렬 가능해야 함
- 초당 10,000개의 ID를 만들 수 있어야 함

## 분산 시스템에서 유일성이 보장되는 ID를 만드는 방법
- 다중 마스터 복제 (Multi-master replication)
- UUID(Universally Unique Identifier)
- 티켓 서버(Ticket server)
- 트위터 스노플레이크(Twitter snowflake) 접근법

### Multi-master Replication
<img width="493" alt="스크린샷 2024-08-08 오전 7 36 58" src="https://github.com/user-attachments/assets/f8706807-bf2f-48c4-9051-4535e2834d82">

데이터베이스의 auto_increment 기능을 활용하는 것
but, 다음 ID의 값을 구할 때 **K**만큼 증가 (K는 현재 사용 중인 데이터베이스 서버의 수)
이 구조는 규모 확장성 문제를 어느정도 해결할 수 있다.

**단점**
- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
- ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.

### UUID
UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 **128비트**짜리 수다.
UUID 값은 충돌 가능성이 지극히 낮다.
UUID는 서버 간 조율 없이 독립적으로 생성 가능하다.

<img width="721" alt="스크린샷 2024-08-08 오전 7 41 51" src="https://github.com/user-attachments/assets/27bc835f-3732-4c03-902a-66135d5aab68">
각 웹서버가 별도의 ID 생성기를 사용해 독립적으로 ID를 만들어낸다.

**장점**
- UUID를 만드는 것이 단순하다.
- 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.

**단점**
- ID가 128비트로 길다.
- ID를 시간순으로 정렬할 수 없다.
- ID에 숫자가 아닌 값이 포함될 수 있다.

### Ticket Server

<img width="567" alt="스크린샷 2024-08-08 오전 7 45 22" src="https://github.com/user-attachments/assets/208cccb2-db5c-458b-aa09-99afbdb56058">

이 아이디어의 핵심은 auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티멧 서버를 중앙 집중형으로 하ㅁ나만 사용하는 것이다.

**장점**
- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.

**단점**
- 티켓 서버가 SPOF(Single-Point-of-Failure)가 된다.

### Twitter Snowflake

<img width="620" alt="스크린샷 2024-08-08 오전 7 48 56" src="https://github.com/user-attachments/assets/eeaf664f-0b3b-486c-8312-ee1421a52c42">

**ID section 구조**
- Sign bit
    - 1bit
    - 지금으로 서는 쓰임새가 없지만 나중을 위해 유보해 둔다.
- Timestamp
    - 41bit
    - 기원 시각(epoch) 이후로 몇 millisecond가 경과했는지 나타내는 값
    - 2^41 밀리초로 대략 69년동안만 정상 동작할 수 있다.
    - 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 다른 것으로 이전해야 한다.
- Data Center ID
    - 5bit
    - 2^5로 총 32개의 데이터센터를 지원할 수 있다.
- Server ID
    - 5bit
    - 2^5로 데이터센터당 32개의 서버를 사용할 수 있다.
- Serial Number
    - 12bit
    - 각 서버에서는 ID를 생성할 때마다 이 일련번호를 1 증가시킨다.
    - 1 밀리초가 경과할 때마다 일련번호를 1만큼 증가시킨다.
    - 이 값은 1 밀리초가 경과할 때마다 0으로 초기화 된다.

데이터센터 ID와 서버 ID는 시스템이 시작할 때 결정되며, 일반적으로 시스템 운영 중에는 바뀌지 않는다. 데이터센터 ID와 서버 ID를 잘못 변경하게 되면 ID 충돌이 발생할 수 있으므로, 그런 작업을 해야 할 때는 신중해야 한다.

**고려해야 할 점**
- 시계 동기화
    - ID 생성 서버들이 전부 같은 시계를 사용해야 한다. 하지만 이런 가정은 하나의 서버가 여러 코어에서 실행될 경우 유효하지 않을 수 있다. 또, 여러 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우에도 마찬가지다. **NTP(Network Time Protocol)**을 활용해서 이 문제를 해결할 수 잇다.
- 각 section의 길이 최적화
    - 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적일 수 있다.
- 고가용성
    - ID 생성기는 필수 불가결(mission critical) 컴포넌트이므로 아주 높은 가용성을 제공해야할 것이다.